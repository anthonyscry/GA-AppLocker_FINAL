<#
.SYNOPSIS
    Exports AppLocker policy in GPO-ready formats.

.DESCRIPTION
    Converts an AppLocker policy XML into formats suitable for Group Policy deployment:
    - GPO backup format (importable via GPMC)
    - PowerShell script for Set-AppLockerPolicy
    - Registry export (.reg) for manual deployment
    - SCCM/Intune configuration baseline format

.PARAMETER PolicyPath
    Path to the AppLocker policy XML file.

.PARAMETER OutputPath
    Directory for exported files.

.PARAMETER Format
    Export format(s): GPOBackup, PowerShell, Registry, SCCM, All (default: All)

.PARAMETER GPOName
    Name for the GPO backup (default: "AppLocker Policy - GA-AppLocker")

.PARAMETER Description
    Description for the exported policy.

.EXAMPLE
    .\Export-AppLockerGPO.ps1 -PolicyPath .\policy.xml -OutputPath .\GPO

.EXAMPLE
    .\Export-AppLockerGPO.ps1 -PolicyPath .\policy.xml -Format PowerShell,Registry

.NOTES
    GPO backup format requires the GroupPolicy module (RSAT).
    The script creates self-contained exports that can be deployed independently.
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory)]
    [ValidateScript({ Test-Path $_ })]
    [string]$PolicyPath,

    [string]$OutputPath = '.\GPO-Export',

    [ValidateSet('GPOBackup', 'PowerShell', 'Registry', 'SCCM', 'Intune', 'All')]
    [string[]]$Format = @('All'),

    [string]$GPOName = 'AppLocker Policy - GA-AppLocker',

    [string]$Description = 'AppLocker policy generated by GA-AppLocker toolkit'
)

$ErrorActionPreference = 'Stop'

# Get module root
$scriptRoot = Split-Path $PSScriptRoot -Parent

# Import common functions and error handling
Import-Module (Join-Path $scriptRoot 'utilities\Common.psm1') -Force
Import-Module (Join-Path $PSScriptRoot 'ErrorHandling.psm1') -Force

#region Helper Functions

function Get-PolicyCollections {
    param([xml]$PolicyXml)

    $collections = @{}

    foreach ($ruleCollection in $PolicyXml.AppLockerPolicy.RuleCollection) {
        $type = $ruleCollection.Type
        $mode = $ruleCollection.EnforcementMode

        $rules = @()
        foreach ($rule in $ruleCollection.ChildNodes) {
            if ($rule.NodeType -eq 'Element') {
                $rules += @{
                    Type = $rule.LocalName
                    Id = $rule.Id
                    Name = $rule.Name
                    Description = $rule.Description
                    UserOrGroupSid = $rule.UserOrGroupSid
                    Action = $rule.Action
                    Conditions = $rule.Conditions
                }
            }
        }

        $collections[$type] = @{
            EnforcementMode = $mode
            Rules = $rules
        }
    }

    return $collections
}

function Export-PowerShellDeployment {
    param(
        [string]$PolicyPath,
        [string]$OutputPath,
        [string]$Description
    )

    $scriptPath = Join-Path $OutputPath 'Deploy-AppLockerPolicy.ps1'
    $policyFileName = Split-Path $PolicyPath -Leaf

    # Read policy content for embedding
    $policyContent = Get-Content $PolicyPath -Raw

    $scriptContent = @"
<#
.SYNOPSIS
    Deploys AppLocker policy to local machine.

.DESCRIPTION
    $Description

    Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
    Source: $policyFileName

.PARAMETER Merge
    Merge with existing policy instead of replacing.

.PARAMETER WhatIf
    Show what would happen without making changes.

.EXAMPLE
    .\Deploy-AppLockerPolicy.ps1

.EXAMPLE
    .\Deploy-AppLockerPolicy.ps1 -Merge

.NOTES
    Requires administrator privileges.
    Original policy generated by GA-AppLocker toolkit.
#>

#Requires -RunAsAdministrator
#Requires -Version 5.1

[CmdletBinding(SupportsShouldProcess)]
param(
    [switch]`$Merge
)

`$ErrorActionPreference = 'Stop'

# Embedded policy XML
`$policyXml = @'
$policyContent
'@

Write-Host "`nAppLocker Policy Deployment" -ForegroundColor Cyan
Write-Host "===========================`n" -ForegroundColor Cyan

# Check AppLocker service
`$appidSvc = Get-Service -Name AppIDSvc -ErrorAction SilentlyContinue
if (-not `$appidSvc) {
    Write-Host "ERROR: Application Identity service not found." -ForegroundColor Red
    Write-Host "       AppLocker requires Windows Enterprise/Education edition." -ForegroundColor Yellow
    exit 1
}

if (`$appidSvc.Status -ne 'Running') {
    Write-Host "Starting Application Identity service..." -ForegroundColor Yellow
    Start-Service -Name AppIDSvc
    Set-Service -Name AppIDSvc -StartupType Automatic
}

# Create temp file for policy
`$tempFile = [System.IO.Path]::GetTempFileName()
`$policyXml | Out-File `$tempFile -Encoding UTF8

try {
    if (`$Merge) {
        Write-Host "Merging policy with existing..." -ForegroundColor Yellow
        if (`$PSCmdlet.ShouldProcess("Local AppLocker Policy", "Merge policy")) {
            Set-AppLockerPolicy -XmlPolicy `$tempFile -Merge
        }
    } else {
        Write-Host "Replacing existing policy..." -ForegroundColor Yellow
        if (`$PSCmdlet.ShouldProcess("Local AppLocker Policy", "Replace policy")) {
            Set-AppLockerPolicy -XmlPolicy `$tempFile
        }
    }

    Write-Host "`nPolicy deployed successfully!" -ForegroundColor Green

    # Show summary
    Write-Host "`nPolicy Summary:" -ForegroundColor Cyan
    `$currentPolicy = Get-AppLockerPolicy -Local
    foreach (`$collection in `$currentPolicy.RuleCollections) {
        Write-Host "  `$(`$collection.RuleCollectionType): `$(`$collection.Count) rules (`$(`$collection.EnforcementMode))" -ForegroundColor Gray
    }
}
finally {
    Remove-Item `$tempFile -Force -ErrorAction SilentlyContinue
}

Write-Host "`nDone.`n" -ForegroundColor Green
"@

    $scriptContent | Out-File $scriptPath -Encoding UTF8

    # Also copy the raw XML
    Copy-Item $PolicyPath -Destination (Join-Path $OutputPath 'AppLockerPolicy.xml')

    return @{
        Script = $scriptPath
        Policy = Join-Path $OutputPath 'AppLockerPolicy.xml'
    }
}

function Export-RegistryFormat {
    param(
        [xml]$PolicyXml,
        [string]$OutputPath
    )

    $regPath = Join-Path $OutputPath 'AppLockerPolicy.reg'

    # AppLocker stores policy in registry under:
    # HKLM\SOFTWARE\Policies\Microsoft\Windows\SrpV2

    $regContent = @"
Windows Registry Editor Version 5.00

; AppLocker Policy Export
; Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
; Generated by: GA-AppLocker toolkit
;
; IMPORTANT: This exports the policy structure.
; For full deployment, use GPO or Set-AppLockerPolicy cmdlet.

[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\SrpV2]

"@

    $collections = Get-PolicyCollections -PolicyXml $PolicyXml

    foreach ($collectionType in $collections.Keys) {
        $collection = $collections[$collectionType]
        $regKey = switch ($collectionType) {
            'Exe' { 'Exe' }
            'Msi' { 'Msi' }
            'Script' { 'Script' }
            'Dll' { 'Dll' }
            'Appx' { 'Appx' }
        }

        $regContent += @"

[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\SrpV2\$regKey]
"EnforcementMode"=dword:$(if ($collection.EnforcementMode -eq 'Enabled') { '00000001' } else { '00000000' })

"@

        foreach ($rule in $collection.Rules) {
            $ruleId = $rule.Id
            $regContent += @"

[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\SrpV2\$regKey\$ruleId]
"Value"="$($rule.Name -replace '"', '\"')"

"@
        }
    }

    $regContent | Out-File $regPath -Encoding Unicode

    return $regPath
}

function Export-SCCMBaseline {
    param(
        [xml]$PolicyXml,
        [string]$OutputPath,
        [string]$PolicyPath,
        [string]$Description
    )

    $cabPath = Join-Path $OutputPath 'AppLockerBaseline.cab'
    $xmlPath = Join-Path $OutputPath 'AppLockerBaseline.xml'

    # Create SCCM Configuration Item XML
    $baselineGuid = [guid]::NewGuid().ToString()
    $ciGuid = [guid]::NewGuid().ToString()

    # Read policy for embedding
    $policyContent = Get-Content $PolicyPath -Raw
    $escapedPolicy = [System.Security.SecurityElement]::Escape($policyContent)

    $baselineXml = @"
<?xml version="1.0" encoding="utf-8"?>
<DesiredConfigurationDigest xmlns="http://schemas.microsoft.com/SystemsCenterConfigurationManager/2009/07/10/DesiredConfiguration">
  <Baseline AuthoringScopeId="GA-AppLocker" LogicalName="Baseline_$baselineGuid" Version="1">
    <Annotation>
      <DisplayName Text="AppLocker Policy Baseline" />
      <Description Text="$Description" />
    </Annotation>
    <Parts>
      <ConfigurationItemReference AuthoringScopeId="GA-AppLocker" LogicalName="CI_$ciGuid" Version="1" />
    </Parts>
  </Baseline>
  <ApplicationSettings AuthoringScopeId="GA-AppLocker" LogicalName="CI_$ciGuid" Version="1">
    <Annotation>
      <DisplayName Text="AppLocker Policy Configuration" />
      <Description Text="Ensures AppLocker policy is applied" />
    </Annotation>
    <Settings>
      <RootComplexSetting>
        <SimpleSetting LogicalName="AppLockerPolicy" DataType="String">
          <Annotation>
            <DisplayName Text="AppLocker Policy XML" />
          </Annotation>
          <ScriptDiscoverySource Is64Bit="true">
            <DiscoveryScriptBody ScriptType="PowerShell"><![CDATA[
`$policy = Get-AppLockerPolicy -Local -Xml
`$policy
            ]]></DiscoveryScriptBody>
          </ScriptDiscoverySource>
        </SimpleSetting>
      </RootComplexSetting>
    </Settings>
    <Rules>
      <Rule Id="Rule_$([guid]::NewGuid().ToString())" Severity="Critical" NonCompliantWhenSettingIsNotFound="true">
        <Annotation>
          <DisplayName Text="AppLocker Policy Applied" />
        </Annotation>
        <Expression>
          <Operator>NotEquals</Operator>
          <Operands>
            <SettingReference AuthoringScopeId="GA-AppLocker" LogicalName="CI_$ciGuid" Version="1" DataType="String" SettingLogicalName="AppLockerPolicy" />
            <ConstantValue Value="" DataType="String" />
          </Operands>
        </Expression>
      </Rule>
    </Rules>
    <RemediationScript Is64Bit="true">
      <RemediationScriptBody ScriptType="PowerShell"><![CDATA[

`$policyXml = @'
$policyContent
'@

`$tempFile = [System.IO.Path]::GetTempFileName()
`$policyXml | Out-File `$tempFile -Encoding UTF8
Set-AppLockerPolicy -XmlPolicy `$tempFile
Remove-Item `$tempFile -Force
      ]]></RemediationScriptBody>
    </RemediationScript>
  </ApplicationSettings>
</DesiredConfigurationDigest>
"@

    $baselineXml | Out-File $xmlPath -Encoding UTF8

    # Note: Creating actual CAB requires makecab.exe
    Write-Host "  Note: CAB packaging requires manual creation with makecab.exe" -ForegroundColor Yellow

    return @{
        XML = $xmlPath
        CAB = $null
    }
}

function Export-IntuneFormat {
    param(
        [xml]$PolicyXml,
        [string]$OutputPath,
        [string]$PolicyPath,
        [string]$Description
    )

    $jsonPath = Join-Path $OutputPath 'IntuneAppLockerPolicy.json'
    $ps1Path = Join-Path $OutputPath 'IntuneRemediation.ps1'

    # Read policy content
    $policyContent = Get-Content $PolicyPath -Raw
    $base64Policy = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($policyContent))

    # Create Intune custom OMA-URI configuration
    $intuneConfig = @{
        '@odata.type' = '#microsoft.graph.windows10CustomConfiguration'
        displayName = 'AppLocker Policy'
        description = $Description
        omaSettings = @(
            @{
                '@odata.type' = '#microsoft.graph.omaSettingString'
                displayName = 'AppLocker Exe Rules'
                description = 'Executable rules'
                omaUri = './Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/EXEGroup/EXE/Policy'
                value = $policyContent
            }
        )
    }

    $intuneConfig | ConvertTo-Json -Depth 10 | Out-File $jsonPath -Encoding UTF8

    # Create remediation script for Intune
    $remediationScript = @"
<#
.SYNOPSIS
    Intune Proactive Remediation - Deploy AppLocker Policy

.DESCRIPTION
    $Description
    Generated by GA-AppLocker toolkit

.NOTES
    Deploy as Intune Proactive Remediation script.
    Detection script checks if policy is applied.
    Remediation script applies the policy.
#>

# ==== DETECTION SCRIPT ====
# Save this separately as Detection.ps1

<#
`$currentPolicy = Get-AppLockerPolicy -Local -Xml -ErrorAction SilentlyContinue
if (`$currentPolicy) {
    # Check if our policy markers exist
    if (`$currentPolicy -match 'GA-AppLocker') {
        Write-Host "Policy is applied"
        exit 0
    }
}
Write-Host "Policy needs to be applied"
exit 1
#>

# ==== REMEDIATION SCRIPT ====

`$policyBase64 = '$base64Policy'
`$policyXml = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(`$policyBase64))

# Ensure AppIDSvc is running
`$svc = Get-Service -Name AppIDSvc -ErrorAction SilentlyContinue
if (`$svc -and `$svc.Status -ne 'Running') {
    Start-Service -Name AppIDSvc
    Set-Service -Name AppIDSvc -StartupType Automatic
}

# Apply policy
`$tempFile = [System.IO.Path]::GetTempFileName()
try {
    `$policyXml | Out-File `$tempFile -Encoding UTF8
    Set-AppLockerPolicy -XmlPolicy `$tempFile
    Write-Host "Policy applied successfully"
    exit 0
}
catch {
    Write-Host "Failed to apply policy: `$_"
    exit 1
}
finally {
    Remove-Item `$tempFile -Force -ErrorAction SilentlyContinue
}
"@

    $remediationScript | Out-File $ps1Path -Encoding UTF8

    return @{
        JSON = $jsonPath
        Remediation = $ps1Path
    }
}

function Export-GPOBackup {
    param(
        [string]$PolicyPath,
        [string]$OutputPath,
        [string]$GPOName,
        [string]$Description
    )

    $gpoBackupPath = Join-Path $OutputPath 'GPOBackup'

    # Check if GroupPolicy module is available
    $gpModule = Get-Module -ListAvailable -Name GroupPolicy
    if (-not $gpModule) {
        Write-Host "  WARNING: GroupPolicy module not available (requires RSAT)" -ForegroundColor Yellow
        Write-Host "  Creating manual import instructions instead..." -ForegroundColor Yellow

        $instructionsPath = Join-Path $OutputPath 'GPO-Import-Instructions.txt'
        $instructions = @"
GPO Import Instructions
=======================

The GroupPolicy module is not available on this system.
To import this AppLocker policy via GPO, follow these steps:

Option 1: Using Group Policy Management Console (GPMC)
-------------------------------------------------------
1. Open GPMC (gpmc.msc)
2. Create a new GPO or edit an existing one
3. Navigate to: Computer Configuration > Policies > Windows Settings >
   Security Settings > Application Control Policies > AppLocker
4. Right-click on AppLocker and select "Import Policy..."
5. Browse to: $PolicyPath
6. Link the GPO to appropriate OUs

Option 2: Using PowerShell on a Domain Controller
-------------------------------------------------
Run these commands on a domain controller or machine with RSAT:

```powershell

# Import policy to new GPO

`$gpoName = "$GPOName"
`$policyPath = "$PolicyPath"

# Create new GPO

New-GPO -Name `$gpoName -Comment "$Description"

# Import AppLocker policy (requires copying XML to DC)

`$gpo = Get-GPO -Name `$gpoName
Set-AppLockerPolicy -XmlPolicy `$policyPath -Ldap "LDAP://CN={`$(`$gpo.Id)},CN=Policies,CN=System,DC=yourdomain,DC=com"
```

Option 3: Using Set-AppLockerPolicy locally
-------------------------------------------
For immediate testing on a single machine:

```powershell
Set-AppLockerPolicy -XmlPolicy "$PolicyPath"
```

Files Included
--------------
- AppLockerPolicy.xml - The policy file for import
- Deploy-AppLockerPolicy.ps1 - Script for local deployment

Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Generated by: GA-AppLocker toolkit
"@

        $instructions | Out-File $instructionsPath -Encoding UTF8
        Copy-Item $PolicyPath -Destination (Join-Path $OutputPath 'AppLockerPolicy.xml')

        return @{
            Instructions = $instructionsPath
            Policy = Join-Path $OutputPath 'AppLockerPolicy.xml'
        }
    }

    # GroupPolicy module is available - create proper backup structure
    Write-Host "  Creating GPO backup structure..." -ForegroundColor Gray

    # Create GPO backup folder structure
    $gpoGuid = [guid]::NewGuid().ToString().ToUpper()
    $backupGuid = [guid]::NewGuid().ToString().ToUpper()

    $gpoFolder = Join-Path $gpoBackupPath "{$backupGuid}"
    New-Item -ItemType Directory -Path $gpoFolder -Force | Out-Null

    # Copy policy
    $machineFolder = Join-Path $gpoFolder 'DomainSysvol\GPO\Machine\Microsoft\Windows NT\SecEdit'
    New-Item -ItemType Directory -Path $machineFolder -Force | Out-Null

    # For AppLocker, the policy goes in a specific location
    $applockerFolder = Join-Path $gpoFolder 'DomainSysvol\GPO\Machine\Registry.pol'

    # Create backup.xml
    $backupXml = @"
<?xml version="1.0" encoding="utf-8"?>
<GroupPolicyBackupScheme bkp:version="2.0" bkp:type="GroupPolicyBackup" xmlns:bkp="http://www.microsoft.com/GroupPolicy/GPOOperations" xmlns="http://www.microsoft.com/GroupPolicy/GPOOperations">
  <GroupPolicyObject>
    <SecurityGroups>
      <Group bkp:Source="FromDACL">
        <Sid>S-1-5-32-544</Sid>
        <SamAccountName>Administrators</SamAccountName>
        <Type>Alias</Type>
        <FullControlPermission>true</FullControlPermission>
        <ApplyGroupPolicyPermission>false</ApplyGroupPolicyPermission>
        <ReadPermission>true</ReadPermission>
        <EditPermission>true</EditPermission>
        <DeletePermission>true</DeletePermission>
        <ModifySecurityPermission>true</ModifySecurityPermission>
      </Group>
    </SecurityGroups>
    <FilePaths>
      <Path>\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\SYSVOL\domain\Policies\{$gpoGuid}</Path>
    </FilePaths>
  </GroupPolicyObject>
  <BackupInst bkp:backupId="{$backupGuid}" bkp:gpoId="{$gpoGuid}">
    <GPODomain>$env:USERDNSDOMAIN</GPODomain>
    <GPODomainGuid>{$([guid]::NewGuid().ToString().ToUpper())}</GPODomainGuid>
    <GPODomainController>DC.$env:USERDNSDOMAIN</GPODomainController>
    <BackupTime>$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ss')</BackupTime>
    <Comment>$Description</Comment>
    <GPODisplayName>$GPOName</GPODisplayName>
  </BackupInst>
</GroupPolicyBackupScheme>
"@

    $backupXml | Out-File (Join-Path $gpoFolder 'backup.xml') -Encoding UTF8

    # Create bkupInfo.xml
    $bkupInfoXml = @"
<?xml version="1.0" encoding="utf-8"?>
<BackupInst xmlns="http://www.microsoft.com/GroupPolicy/GPOOperations">
  <GPOGuid>{$gpoGuid}</GPOGuid>
  <GPODomain>$env:USERDNSDOMAIN</GPODomain>
  <GPODomainGuid>{$([guid]::NewGuid().ToString().ToUpper())}</GPODomainGuid>
  <GPODisplayName>$GPOName</GPODisplayName>
  <BackupTime>$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ss')</BackupTime>
  <Comment>$Description</Comment>
  <BackupGuid>{$backupGuid}</BackupGuid>
</BackupInst>
"@

    $bkupInfoXml | Out-File (Join-Path $gpoFolder 'bkupInfo.xml') -Encoding UTF8

    # Copy the AppLocker policy
    Copy-Item $PolicyPath -Destination (Join-Path $gpoFolder 'AppLockerPolicy.xml')

    # Create import script
    $importScript = @"
<#
.SYNOPSIS
    Imports the AppLocker GPO backup.

.DESCRIPTION
    Imports the GPO backup created by GA-AppLocker.
    Requires GroupPolicy module (RSAT) and domain admin privileges.

.EXAMPLE
    .\Import-AppLockerGPO.ps1 -TargetName "AppLocker Production"
#>

param(
    [string]`$TargetName = "$GPOName"
)

`$backupPath = Split-Path `$PSScriptRoot -Parent
Import-GPO -BackupId "{$backupGuid}" -Path `$backupPath -TargetName `$TargetName -CreateIfNeeded

Write-Host "GPO imported: `$TargetName" -ForegroundColor Green
Write-Host "Remember to link the GPO to appropriate OUs." -ForegroundColor Yellow
"@

    $importScript | Out-File (Join-Path $gpoFolder 'Import-AppLockerGPO.ps1') -Encoding UTF8

    return @{
        BackupPath = $gpoBackupPath
        BackupId = $backupGuid
        ImportScript = Join-Path $gpoFolder 'Import-AppLockerGPO.ps1'
    }
}

#endregion

#region Main

Write-SectionHeader -Title "AppLocker GPO Export"

# Validate policy using standardized function
Write-Host "Validating policy..." -ForegroundColor Yellow
$policyXml = Test-ValidAppLockerPolicy -Path $PolicyPath
if (-not $policyXml) {
    Write-ErrorMessage -Message "Invalid policy XML: $PolicyPath" -Throw
}

$collections = Get-PolicyCollections -PolicyXml $policyXml
Write-Host "  Policy contains:" -ForegroundColor Gray
foreach ($type in $collections.Keys) {
    $col = $collections[$type]
    Write-Host "    $type`: $($col.Rules.Count) rules ($($col.EnforcementMode))" -ForegroundColor Gray
}

# Create output directory using standardized validation
$validOutputPath = Test-ValidPath -Path $OutputPath -Type Directory -CreateIfMissing
if (-not $validOutputPath) {
    Write-ErrorMessage -Message "Failed to create output directory: $OutputPath" -Throw
}

# Determine formats to export
$formatsToExport = if ('All' -in $Format) {
    @('GPOBackup', 'PowerShell', 'Registry', 'SCCM', 'Intune')
} else {
    $Format
}

Write-Host "`nExporting formats: $($formatsToExport -join ', ')" -ForegroundColor Yellow
Write-Host ""

$results = @{}

$stepNum = 0
$totalFormats = $formatsToExport.Count

foreach ($fmt in $formatsToExport) {
    $stepNum++
    Write-StepProgress -Step $stepNum -Total $totalFormats -Message "Exporting $fmt format"

    $exportResult = Invoke-SafeOperation -ScriptBlock {
        switch ($fmt) {
            'PowerShell' {
                Export-PowerShellDeployment -PolicyPath $PolicyPath -OutputPath $validOutputPath -Description $Description
            }
            'Registry' {
                Export-RegistryFormat -PolicyXml $policyXml -OutputPath $validOutputPath
            }
            'SCCM' {
                Export-SCCMBaseline -PolicyXml $policyXml -OutputPath $validOutputPath -PolicyPath $PolicyPath -Description $Description
            }
            'Intune' {
                Export-IntuneFormat -PolicyXml $policyXml -OutputPath $validOutputPath -PolicyPath $PolicyPath -Description $Description
            }
            'GPOBackup' {
                Export-GPOBackup -PolicyPath $PolicyPath -OutputPath $validOutputPath -GPOName $GPOName -Description $Description
            }
        }
    } -ErrorMessage "Failed to export $fmt format" -ContinueOnError

    if ($exportResult) {
        $results[$fmt] = $exportResult
        switch ($fmt) {
            'PowerShell' { Write-SuccessMessage -Message "Created: $($results[$fmt].Script)" }
            'Registry' { Write-SuccessMessage -Message "Created: $($results[$fmt])" }
            'SCCM' { Write-SuccessMessage -Message "Created: $($results[$fmt].XML)" }
            'Intune' {
                Write-SuccessMessage -Message "Created: $($results[$fmt].JSON)"
                Write-SuccessMessage -Message "Created: $($results[$fmt].Remediation)"
            }
            'GPOBackup' {
                if ($results[$fmt].BackupPath) {
                    Write-SuccessMessage -Message "Created: $($results[$fmt].BackupPath)"
                } else {
                    Write-Host "  Created: $($results[$fmt].Instructions)" -ForegroundColor Yellow
                }
            }
        }
    }
}

Write-SectionHeader -Title "Export Complete"

Write-Host "Output directory: $validOutputPath" -ForegroundColor Yellow
Write-Host ""
Get-ChildItem $OutputPath -Recurse -File | ForEach-Object {
    $relativePath = $_.FullName.Replace($OutputPath, '').TrimStart('\')
    Write-Host "  $relativePath" -ForegroundColor Gray
}
Write-Host ""

return $results

#endregion
