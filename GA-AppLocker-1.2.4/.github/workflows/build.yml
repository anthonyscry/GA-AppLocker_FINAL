name: Build GA-AppLocker

on:
  push:
    branches: [ main, master, develop ]
    paths:
      - 'src/**'
      - '*.ps1'
      - 'utilities/**'
      - 'GUI/**'
      - '.github/workflows/build.yml'
      - '*.sln'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: false
        default: ''
      create_release:
        description: 'Create GitHub release'
        required: false
        type: boolean
        default: false
      skip_tests:
        description: 'Skip tests and code review (manual dispatch only, not PRs)'
        required: false
        type: boolean
        default: false
      debug:
        description: 'Enable debug output'
        required: false
        type: boolean
        default: false

# Prevent concurrent runs on the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Default permissions - least privilege principle
permissions:
  contents: read

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: 'src/GA-AppLocker.App/GA-AppLocker.App.csproj'

jobs:
  #############################################
  # PowerShell Code Review & Security Checks
  #############################################
  code-review:
    name: PowerShell Code Review
    runs-on: windows-latest
    # Only allow skip_tests on manual dispatch, never on PRs (security requirement)
    if: ${{ !(github.event.inputs.skip_tests == 'true' && github.event_name == 'workflow_dispatch') }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Environment Diagnostics
      if: github.event.inputs.debug == 'true'
      shell: pwsh
      run: |
        Write-Host "=== Environment Diagnostics ===" -ForegroundColor Cyan
        Write-Host ""
        Write-Host "PowerShell Version:" -ForegroundColor Yellow
        $PSVersionTable | Format-Table -AutoSize
        Write-Host ""
        Write-Host "OS Information:" -ForegroundColor Yellow
        [System.Environment]::OSVersion | Format-List
        Write-Host ""
        Write-Host "Working Directory:" -ForegroundColor Yellow
        Get-Location
        Write-Host ""
        Write-Host "Repository Files:" -ForegroundColor Yellow
        Get-ChildItem -Path . -Recurse -File -Include *.ps1,*.psm1,*.psd1 |
          Select-Object FullName, Length, LastWriteTime |
          Format-Table -AutoSize
        Write-Host ""
        Write-Host "Git Info:" -ForegroundColor Yellow
        git log -1 --format="Commit: %H%nAuthor: %an%nDate: %ai%nMessage: %s"

    - name: Install PSScriptAnalyzer
      shell: pwsh
      run: |
        Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
        Install-Module -Name PSScriptAnalyzer -MinimumVersion 1.21.0 -Force -Scope CurrentUser
        Get-Module -Name PSScriptAnalyzer -ListAvailable | Select-Object Name, Version

    - name: Run PSScriptAnalyzer - Code Quality
      id: lint
      shell: pwsh
      run: |
        Write-Host "=== Running PSScriptAnalyzer Code Quality Check ===" -ForegroundColor Cyan

        $results = @()

        # Rules to exclude globally
        # - PSAvoidUsingWriteHost: Appropriate for CLI tools with user feedback
        # - PSUseConsistentIndentation: Project uses scriptblock-reset style
        # - PSUseConsistentWhitespace: Conflicts with scriptblock indentation style
        # - PSUseBOMForUnicodeEncodedFile: BOM not required for UTF-8 in modern systems
        $excludeRules = @(
          'PSAvoidUsingWriteHost',
          'PSUseConsistentIndentation',
          'PSUseConsistentWhitespace',
          'PSUseBOMForUnicodeEncodedFile'
        )

        # Analyze all PowerShell files
        $psFiles = Get-ChildItem -Path . -Include *.ps1, *.psm1, *.psd1 -Recurse -File |
                   Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\' }

        Write-Host "Found $($psFiles.Count) PowerShell files to analyze"

        foreach ($file in $psFiles) {
          $fileResults = Invoke-ScriptAnalyzer -Path $file.FullName -ExcludeRule $excludeRules -Severity Warning, Error
          if ($fileResults) {
            $results += $fileResults
          }
        }

        # Output results
        $errors = $results | Where-Object { $_.Severity -eq 'Error' }
        $warnings = $results | Where-Object { $_.Severity -eq 'Warning' }

        Write-Host ""
        Write-Host "=== Results ===" -ForegroundColor Cyan
        Write-Host "Errors: $($errors.Count)" -ForegroundColor $(if ($errors.Count -gt 0) { 'Red' } else { 'Green' })
        Write-Host "Warnings: $($warnings.Count)" -ForegroundColor $(if ($warnings.Count -gt 0) { 'Yellow' } else { 'Green' })

        if ($results.Count -gt 0) {
          Write-Host ""
          Write-Host "=== Issues Found ===" -ForegroundColor Yellow
          $results | Group-Object ScriptName | ForEach-Object {
            Write-Host ""
            Write-Host "File: $($_.Name)" -ForegroundColor White
            $_.Group | ForEach-Object {
              $color = if ($_.Severity -eq 'Error') { 'Red' } else { 'Yellow' }
              Write-Host "  Line $($_.Line): [$($_.Severity)] $($_.RuleName)" -ForegroundColor $color
              Write-Host "    $($_.Message)" -ForegroundColor Gray

              # GitHub file annotations - shows in PR diff view
              $level = if ($_.Severity -eq 'Error') { 'error' } else { 'warning' }
              $file = $_.ScriptName -replace '^.*[/\\]', ''
              Write-Host "::$level file=$($_.ScriptName),line=$($_.Line),col=$($_.Column)::[$($_.RuleName)] $($_.Message)"
            }
          }
        }

        # Export for artifact
        $results | Select-Object ScriptName, Line, Column, Severity, RuleName, Message |
          Export-Csv -Path "./lint-results.csv" -NoTypeInformation

        # Set outputs before potential exit
        echo "WARNINGS=$($warnings.Count)" >> $env:GITHUB_OUTPUT
        echo "ERRORS=$($errors.Count)" >> $env:GITHUB_OUTPUT

        # Fail on errors
        if ($errors.Count -gt 0) {
          Write-Host ""
          Write-Host "::error::PSScriptAnalyzer found $($errors.Count) error(s)"
          exit 1
        }

    - name: Run PSScriptAnalyzer - Security Rules
      id: security
      shell: pwsh
      run: |
        Write-Host "=== Running Security Analysis ===" -ForegroundColor Cyan

        # Security-focused rules
        $securityRules = @(
          'PSAvoidUsingPlainTextForPassword',
          'PSAvoidUsingConvertToSecureStringWithPlainText',
          'PSAvoidUsingUsernameAndPasswordParams',
          'PSAvoidUsingComputerNameHardcoded',
          'PSUsePSCredentialType',
          'PSAvoidUsingInvokeExpression',
          'PSAvoidUsingCmdletAliases',
          'PSUseDeclaredVarsMoreThanAssignments',
          'PSAvoidGlobalVars',
          'PSAvoidUsingEmptyCatchBlock'
        )

        $psFiles = Get-ChildItem -Path . -Include *.ps1, *.psm1 -Recurse -File |
                   Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\' }

        $securityIssues = @()

        foreach ($file in $psFiles) {
          $issues = Invoke-ScriptAnalyzer -Path $file.FullName -IncludeRule $securityRules
          if ($issues) {
            $securityIssues += $issues
          }
        }

        # Check for hardcoded credentials patterns
        Write-Host ""
        Write-Host "=== Scanning for Hardcoded Secrets ===" -ForegroundColor Cyan

        $secretPatterns = @(
          @{ Name = 'Potential API Key'; Pattern = '(?i)(api[_-]?key|apikey)\s*[=:]\s*[''"][a-zA-Z0-9]{20,}[''"]' },
          @{ Name = 'Potential Password'; Pattern = '(?i)(password|pwd|passwd)\s*[=:]\s*[''"][^''"]{8,}[''"]' },
          @{ Name = 'Potential Token'; Pattern = '(?i)(token|secret|bearer)\s*[=:]\s*[''"][a-zA-Z0-9_-]{20,}[''"]' },
          @{ Name = 'Potential Connection String'; Pattern = '(?i)(connectionstring|connstr)\s*[=:]\s*[''"][^''"]+[''"]' }
        )

        $secretFindings = @()
        foreach ($file in $psFiles) {
          $content = Get-Content -Path $file.FullName -Raw -ErrorAction SilentlyContinue
          if ($content) {
            foreach ($pattern in $secretPatterns) {
              if ($content -match $pattern.Pattern) {
                $secretFindings += [PSCustomObject]@{
                  File = $file.Name
                  Type = $pattern.Name
                  Path = $file.FullName
                }
              }
            }
          }
        }

        # Report security issues
        if ($securityIssues.Count -gt 0) {
          Write-Host ""
          Write-Host "=== Security Rule Violations ===" -ForegroundColor Yellow
          $securityIssues | ForEach-Object {
            Write-Host "[$($_.Severity)] $($_.ScriptName):$($_.Line) - $($_.RuleName)" -ForegroundColor Yellow
            Write-Host "  $($_.Message)" -ForegroundColor Gray
          }
        }

        if ($secretFindings.Count -gt 0) {
          Write-Host ""
          Write-Host "=== Potential Hardcoded Secrets ===" -ForegroundColor Red
          $secretFindings | ForEach-Object {
            Write-Host "::warning file=$($_.Path)::$($_.Type) detected in $($_.File)"
          }
        }

        # Export security report
        $report = @{
          SecurityRuleViolations = $securityIssues.Count
          PotentialSecrets = $secretFindings.Count
          Details = @{
            RuleViolations = $securityIssues | Select-Object ScriptName, Line, RuleName, Message
            SecretFindings = $secretFindings
          }
        }
        $report | ConvertTo-Json -Depth 5 | Out-File -FilePath "./security-report.json"

        Write-Host ""
        Write-Host "=== Security Summary ===" -ForegroundColor Cyan
        Write-Host "Rule Violations: $($securityIssues.Count)"
        Write-Host "Potential Secrets: $($secretFindings.Count)"

        echo "SECURITY_ISSUES=$($securityIssues.Count)" >> $env:GITHUB_OUTPUT
        echo "SECRET_FINDINGS=$($secretFindings.Count)" >> $env:GITHUB_OUTPUT

    - name: Validate XAML
      id: xaml
      shell: pwsh
      run: |
        Write-Host "=== Validating Embedded XAML ===" -ForegroundColor Cyan

        $xamlErrors = @()

        # Find files with embedded XAML
        $psFiles = Get-ChildItem -Path . -Include *.ps1 -Recurse -File |
                   Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\' }

        foreach ($file in $psFiles) {
          $content = Get-Content -Path $file.FullName -Raw -ErrorAction SilentlyContinue
          if ($content -match '\[xml\]\s*\$\w+\s*=\s*@[''"]') {
            Write-Host "Checking XAML in: $($file.Name)"

            # Extract XAML content
            $xamlMatches = [regex]::Matches($content, '@[''"][\s\S]*?<Window[\s\S]*?</Window>[\s\S]*?[''"]@')

            foreach ($match in $xamlMatches) {
              try {
                $xamlContent = $match.Value -replace '^@[''"]', '' -replace '[''"]@$', ''
                $null = [xml]$xamlContent
                Write-Host "  XAML validated successfully" -ForegroundColor Green
              }
              catch {
                $xamlErrors += [PSCustomObject]@{
                  File = $file.Name
                  Error = $_.Exception.Message
                }
                Write-Host "  XAML Error: $($_.Exception.Message)" -ForegroundColor Red
              }
            }
          }
        }

        # Set outputs before potential exit
        echo "XAML_ERRORS=$($xamlErrors.Count)" >> $env:GITHUB_OUTPUT

        if ($xamlErrors.Count -gt 0) {
          Write-Host ""
          Write-Host "::error::XAML validation failed with $($xamlErrors.Count) error(s)"
          exit 1
        }

        Write-Host ""
        Write-Host "XAML validation passed" -ForegroundColor Green

    - name: Upload lint results
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.0
      if: always()
      with:
        name: code-review-results
        path: |
          ./lint-results.csv
          ./security-report.json
        retention-days: 14

    - name: Generate Job Summary
      if: always()
      shell: pwsh
      run: |
        $summary = @"
        ## PowerShell Code Review Results

        | Check | Result | Details |
        |-------|--------|---------|
        | Code Quality | $(if (${{ steps.lint.outcome == 'success' }}) { 'âœ… Passed' } else { 'âŒ Failed' }) | Errors: ${{ steps.lint.outputs.ERRORS || '0' }}, Warnings: ${{ steps.lint.outputs.WARNINGS || '0' }} |
        | Security Analysis | $(if (${{ steps.security.outcome == 'success' }}) { 'âœ… Passed' } else { 'âš ï¸ Issues' }) | Violations: ${{ steps.security.outputs.SECURITY_ISSUES || '0' }}, Secrets: ${{ steps.security.outputs.SECRET_FINDINGS || '0' }} |
        | XAML Validation | $(if (${{ steps.xaml.outcome == 'success' }}) { 'âœ… Passed' } else { 'âŒ Failed' }) | Errors: ${{ steps.xaml.outputs.XAML_ERRORS || '0' }} |

        ### Files Analyzed
        ``````
        $(Get-ChildItem -Path . -Include *.ps1,*.psm1,*.psd1 -Recurse -File | Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\' } | Measure-Object | Select-Object -ExpandProperty Count) PowerShell files
        ``````

        ---
        *Run ID: ${{ github.run_id }} | Commit: ${{ github.sha }}*
        "@

        $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

  #############################################
  # PowerShell Tests
  #############################################
  test:
    name: PowerShell Tests
    runs-on: windows-latest
    # Only allow skip_tests on manual dispatch, never on PRs (security requirement)
    if: ${{ !(github.event.inputs.skip_tests == 'true' && github.event_name == 'workflow_dispatch') }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Install Pester
      shell: pwsh
      run: |
        Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
        Install-Module -Name Pester -MinimumVersion 5.0.0 -Force -Scope CurrentUser
        Get-Module -Name Pester -ListAvailable | Select-Object Name, Version

    - name: Run Pester Tests with Code Coverage
      id: pester
      shell: pwsh
      run: |
        Write-Host "=== Running Pester Tests with Code Coverage ===" -ForegroundColor Cyan

        # Find all test files
        $testFiles = Get-ChildItem -Path . -Filter "*.Tests.ps1" -Recurse

        if ($testFiles.Count -eq 0) {
          Write-Host "No test files found" -ForegroundColor Yellow
          echo "TESTS_RUN=0" >> $env:GITHUB_OUTPUT
          echo "TESTS_PASSED=0" >> $env:GITHUB_OUTPUT
          echo "TESTS_FAILED=0" >> $env:GITHUB_OUTPUT
          echo "COVERAGE=0" >> $env:GITHUB_OUTPUT
          exit 0
        }

        Write-Host "Found $($testFiles.Count) test file(s):"
        $testFiles | ForEach-Object { Write-Host "  - $($_.Name)" }

        # Find PowerShell files to measure coverage (exclude test files and git)
        $coverageFiles = Get-ChildItem -Path . -Include *.ps1, *.psm1 -Recurse -File |
          Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\' }

        Write-Host ""
        Write-Host "Measuring coverage for $($coverageFiles.Count) file(s)"

        # Configure Pester with code coverage
        $config = New-PesterConfiguration
        $config.Run.Path = $testFiles.FullName
        $config.Run.Exit = $false
        $config.Output.Verbosity = 'Detailed'
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputPath = './test-results.xml'
        $config.TestResult.OutputFormat = 'NUnitXml'

        # Enable code coverage
        $config.CodeCoverage.Enabled = $true
        $config.CodeCoverage.Path = $coverageFiles.FullName
        $config.CodeCoverage.OutputPath = './coverage.xml'
        $config.CodeCoverage.OutputFormat = 'JaCoCo'

        # Run tests
        $results = Invoke-Pester -Configuration $config

        # Calculate coverage percentage
        $coveragePercent = 0
        if ($results.CodeCoverage.CommandsAnalyzedCount -gt 0) {
          $coveragePercent = [math]::Round(
            ($results.CodeCoverage.CommandsExecutedCount / $results.CodeCoverage.CommandsAnalyzedCount) * 100,
            2
          )
        }

        Write-Host ""
        Write-Host "=== Test Summary ===" -ForegroundColor Cyan
        Write-Host "Total: $($results.TotalCount)"
        Write-Host "Passed: $($results.PassedCount)" -ForegroundColor Green
        Write-Host "Failed: $($results.FailedCount)" -ForegroundColor $(if ($results.FailedCount -gt 0) { 'Red' } else { 'Green' })
        Write-Host "Skipped: $($results.SkippedCount)" -ForegroundColor Yellow

        Write-Host ""
        Write-Host "=== Code Coverage ===" -ForegroundColor Cyan
        Write-Host "Commands Analyzed: $($results.CodeCoverage.CommandsAnalyzedCount)"
        Write-Host "Commands Executed: $($results.CodeCoverage.CommandsExecutedCount)"
        Write-Host "Coverage: $coveragePercent%" -ForegroundColor $(if ($coveragePercent -ge 50) { 'Green' } elseif ($coveragePercent -ge 25) { 'Yellow' } else { 'Red' })

        echo "TESTS_RUN=$($results.TotalCount)" >> $env:GITHUB_OUTPUT
        echo "TESTS_PASSED=$($results.PassedCount)" >> $env:GITHUB_OUTPUT
        echo "TESTS_FAILED=$($results.FailedCount)" >> $env:GITHUB_OUTPUT
        echo "COVERAGE=$coveragePercent" >> $env:GITHUB_OUTPUT

        if ($results.FailedCount -gt 0) {
          Write-Host ""
          Write-Host "::error::$($results.FailedCount) test(s) failed"
          exit 1
        }

    - name: Upload test results
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.0
      if: always()
      with:
        name: test-results
        path: |
          ./test-results.xml
          ./coverage.xml
        retention-days: 14

    - name: Generate Test Summary
      if: always()
      shell: pwsh
      run: |
        $passed = '${{ steps.pester.outputs.TESTS_PASSED }}' -as [int]
        $failed = '${{ steps.pester.outputs.TESTS_FAILED }}' -as [int]
        $total = '${{ steps.pester.outputs.TESTS_RUN }}' -as [int]
        $coverage = '${{ steps.pester.outputs.COVERAGE }}' -as [decimal]
        $passRate = if ($total -gt 0) { [math]::Round(($passed / $total) * 100, 1) } else { 0 }

        # Coverage badge color
        $coverageEmoji = if ($coverage -ge 80) { 'ðŸŸ¢' } elseif ($coverage -ge 50) { 'ðŸŸ¡' } else { 'ðŸ”´' }

        $summary = @"
        ## Pester Test Results

        | Metric | Value |
        |--------|-------|
        | Total Tests | $total |
        | âœ… Passed | $passed |
        | âŒ Failed | $failed |
        | Pass Rate | $passRate% |
        | $coverageEmoji Code Coverage | $coverage% |

        $(if ($failed -gt 0) {
          "### âš ï¸ Failed Tests`nCheck the test-results.xml artifact for details."
        } elseif ($total -eq 0) {
          "### â„¹ï¸ No Tests Found`nConsider adding Pester tests to validate functionality."
        } else {
          "### âœ… All Tests Passed"
        })

        ### Code Coverage Details
        Coverage report available in the test-results artifact (coverage.xml in JaCoCo format).

        ---
        *Run ID: ${{ github.run_id }} | Commit: ${{ github.sha }}*
        "@

        $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8

  #############################################
  # Build .NET Application
  #############################################
  build:
    name: Build Application
    runs-on: windows-latest
    needs: [code-review, test]
    if: |
      always() &&
      (needs.code-review.result == 'success' || needs.code-review.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    outputs:
      version: ${{ steps.version.outputs.VERSION }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

    - name: Setup .NET
      uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9  # v4.3.1
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@1bd1e32a3bdc45362d1e726936510720a7c30a57  # v4.2.0
      with:
        path: ~/.nuget/packages
        key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj', '**/Directory.Build.props') }}
        restore-keys: |
          nuget-${{ runner.os }}-

    - name: Get version
      id: version
      shell: pwsh
      run: |
        if ("${{ github.event.inputs.version }}" -ne "") {
          $version = "${{ github.event.inputs.version }}"
        } else {
          $version = Get-Date -Format "yyyy.MM.dd"
          $buildNumber = "${{ github.run_number }}"
          $version = "$version.$buildNumber"
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        Write-Host "Version: $version" -ForegroundColor Cyan

    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Build
      run: |
        dotnet build ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --no-restore `
          -p:Version=${{ steps.version.outputs.VERSION }}

    - name: Publish - Self-contained single file
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --runtime win-x64 `
          --self-contained true `
          -p:PublishSingleFile=true `
          -p:IncludeNativeLibrariesForSelfExtract=true `
          -p:Version=${{ steps.version.outputs.VERSION }} `
          --output ./publish/standalone

    - name: Publish - Framework-dependent
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration Release `
          --runtime win-x64 `
          --self-contained false `
          -p:Version=${{ steps.version.outputs.VERSION }} `
          --output ./publish/framework-dependent

    - name: Copy PowerShell scripts to publish
      shell: pwsh
      run: |
        # Copy scripts to standalone package
        $standaloneScripts = "./publish/standalone/Scripts"
        New-Item -ItemType Directory -Force -Path $standaloneScripts | Out-Null

        # Copy main scripts
        Copy-Item -Path "*.ps1" -Destination $standaloneScripts -Force
        Copy-Item -Path "utilities" -Destination $standaloneScripts -Recurse -Force

        # Create GUI directory and copy files
        $guiDest = Join-Path $standaloneScripts "GUI"
        New-Item -ItemType Directory -Force -Path $guiDest | Out-Null
        Copy-Item -Path "GUI/*.ps1" -Destination $guiDest -Force -ErrorAction SilentlyContinue
        Copy-Item -Path "GUI/*.psm1" -Destination $guiDest -Force -ErrorAction SilentlyContinue

        # Copy to framework-dependent package too
        $fdScripts = "./publish/framework-dependent/Scripts"
        Copy-Item -Path $standaloneScripts -Destination $fdScripts -Recurse -Force

    - name: Create ZIP packages
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.VERSION }}"

        # Standalone package (recommended)
        Compress-Archive -Path "./publish/standalone/*" `
          -DestinationPath "./publish/GA-AppLocker-$version-win-x64-standalone.zip"

        # Framework-dependent package (smaller, requires .NET runtime)
        Compress-Archive -Path "./publish/framework-dependent/*" `
          -DestinationPath "./publish/GA-AppLocker-$version-win-x64-framework-dependent.zip"

        # PowerShell-only package (CLI only, no GUI exe)
        $psOnlyDir = "./publish/powershell-only"
        New-Item -ItemType Directory -Force -Path $psOnlyDir | Out-Null
        Copy-Item -Path "*.ps1" -Destination $psOnlyDir -Force
        Copy-Item -Path "utilities" -Destination $psOnlyDir -Recurse -Force
        Copy-Item -Path "GUI" -Destination $psOnlyDir -Recurse -Force
        Copy-Item -Path "ADManagement" -Destination $psOnlyDir -Recurse -Force -ErrorAction SilentlyContinue
        Copy-Item -Path "README.md" -Destination $psOnlyDir -Force -ErrorAction SilentlyContinue
        Copy-Item -Path "CHANGELOG.md" -Destination $psOnlyDir -Force -ErrorAction SilentlyContinue

        Compress-Archive -Path "$psOnlyDir/*" `
          -DestinationPath "./publish/GA-AppLocker-$version-PowerShell-only.zip"

    - name: Upload standalone artifact
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.0
      with:
        name: GA-AppLocker-standalone-${{ steps.version.outputs.VERSION }}
        path: ./publish/GA-AppLocker-*-standalone.zip
        retention-days: 30

    - name: Upload framework-dependent artifact
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.0
      with:
        name: GA-AppLocker-framework-dependent-${{ steps.version.outputs.VERSION }}
        path: ./publish/GA-AppLocker-*-framework-dependent.zip
        retention-days: 30

    - name: Upload PowerShell-only artifact
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.0
      with:
        name: GA-AppLocker-PowerShell-${{ steps.version.outputs.VERSION }}
        path: ./publish/GA-AppLocker-*-PowerShell-only.zip
        retention-days: 30

  #############################################
  # Create Release
  #############################################
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: github.event.inputs.create_release == 'true'
    permissions:
      contents: write  # Required for creating releases and tags

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4.3.0
      with:
        path: ./artifacts

    - name: Create Release
      uses: softprops/action-gh-release@c95fe1489396fe8a9eb87c0abf8aa5b2ef267fda  # v2.2.1
      with:
        tag_name: v${{ needs.build.outputs.version }}
        name: GA-AppLocker v${{ needs.build.outputs.version }}
        draft: true
        prerelease: false
        files: ./artifacts/**/*.zip
        body: |
          ## GA-AppLocker v${{ needs.build.outputs.version }}

          ### Downloads

          | Package | Description |
          |---------|-------------|
          | `GA-AppLocker-*-standalone.zip` | **Recommended** - Single .exe file, no dependencies needed |
          | `GA-AppLocker-*-framework-dependent.zip` | Smaller package, requires .NET 8 runtime |
          | `GA-AppLocker-*-PowerShell-only.zip` | PowerShell scripts only, no compiled GUI |

          ### Requirements
          - Windows 10/11 or Windows Server 2019+
          - PowerShell 5.1 or higher
          - Administrator privileges for AppLocker operations

          ### Code Quality
          - PSScriptAnalyzer: Passed
          - Security Scan: Passed
          - Pester Tests: Passed

          ### What's New
          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
